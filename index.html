<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 맞춤형 수학 문제 풀이</title>
    
    <!-- 1. Tailwind CSS 로드 -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. Vue.js 로드 -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    
    <!-- [FIX-2] 3. Markdown 파서 (marked.js) 로드 -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <!-- [FIX-1] 4. MathJax (LaTeX 수식 렌더링) 설정 -->
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']] // $...$ 를 인라인 수식으로 명시적 설정
        },
        startup: {
          ready: () => {
            // console.log('MathJax is ready!'); // 디버깅용
            MathJax.startup.defaultReady();
          }
        }
      };
    </script>
    <!-- 5. MathJax 스크립트 로드 -->
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <style>
        /* 기본 폰트 및 배경 설정 */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Tailwind bg-gray-100 */
        }
        /* MathJax 로드 전 깜빡임 방지 */
        .mathjax-container {
            min-height: 5em; /* 문제 영역의 최소 높이 확보 */
        }
        #drawing-canvas {
            touch-action: none; /* 모바일에서 캔버스 터치 시 페이지 스크롤 방지 */
            transition: height 0.3s ease; /* 캔버스 높이 변경 시 부드러운 전환 */
        }
    </style>
</head>
<body class="antiasaed">
    <div id="app" class="container mx-auto max-w-4xl p-4 sm:p-8 min-h-screen">
        
        <!-- 1. API 키 입력 화면 (isApiKeySet이 false일 때) -->
        <div v-if="!isApiKeySet" class="flex items-center justify-center min-h-[80vh]">
            <div class="bg-white p-8 rounded-xl shadow-2xl w-full max-w-md">
                <h2 class="text-3xl font-bold text-center text-gray-800 mb-6">시작하기</h2>
                <p class="text-center text-gray-600 mb-6">
                    Gemini API 키를 입력해주세요. 이 키는 서버에 저장되지 않고, 오직 당신의 브라우저 쿠키에만 안전하게 보관됩니다.
                </p>
                <div class="space-y-4">
                    <input 
                        type="password" 
                        v-model="apiKeyInput"
                        placeholder="Gemini API 키를 여기에 붙여넣으세요"
                        class="w-full px-4 py-3 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 transition"
                    >
                    <button 
                        @click="setApiKey"
                        class="w-full bg-blue-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 transition transform hover:-translate-y-0.5"
                    >
                        시작하기
                    </button>
                </div>
            </div>
        </div>

        <!-- 2. 메인 앱 화면 (isApiKeySet이 true일 때) -->
        <div v-else class="space-y-8">
            <header class="flex justify-between items-center">
                <h1 class="text-4xl font-extrabold text-blue-700">
                    AI 맞춤형 수학 챌린지
                </h1>
                <button @click="clearApiKey" class="text-sm text-gray-500 hover:text-red-600 transition">API 키 변경</button>
            </header>

            <!-- 2.1. 카테고리 선택 화면 -->
            <section v-if="!currentProblem" class="bg-white p-8 rounded-xl shadow-lg">
                <h2 class="text-2xl font-bold text-gray-800 mb-6">학습할 단원을 선택하세요</h2>
                <div v-if="problems.length === 0" class="text-center text-gray-500">
                    문제 데이터를 불러오는 중입니다...
                </div>
                <div v-else class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <button
                        v-for="cat in availableCategories"
                        :key="cat"
                        @click="startQuiz(cat)"
                        class="p-6 border border-gray-200 rounded-lg text-left hover:shadow-md hover:border-blue-400 focus:outline-none focus:ring-2 focus:ring-blue-500 transition"
                    >
                        <span class="text-xl font-semibold text-gray-700">{{ cat }}</span>
                        <div class="text-sm text-gray-500 mt-1">
                            현재 ELO 점수: <span class="font-bold text-blue-600">{{ userRatings[cat] }} / 5</span>
                        </div>
                    </button>
                </div>
            </section>

            <!-- 2.2. 문제 풀이 화면 -->
            <section v-if="currentProblem" class="bg-white p-6 sm:p-8 rounded-xl shadow-lg space-y-6">
                <!-- 문제 정보 및 뒤로 가기 -->
                <div class="flex justify-between items-center mb-4">
                    <button @click="currentProblem = null" class="text-blue-600 hover:text-blue-800 transition">
                        &larr; 단원 선택으로
                    </button>
                    <span class="text-sm font-medium text-gray-500 bg-gray-100 px-3 py-1 rounded-full">
                        {{ currentProblem.category }} (문제 난이도: {{ currentProblem.difficulty }})
                    </span>
                </div>
                
                <!-- 문제 표시 (MathJax 렌더링) -->
                <div 
                    ref="problemContainer" 
                    class="text-xl text-gray-800 leading-relaxed border-b pb-6 mathjax-container"
                >
                    <!-- v-html 제거됨. 수식이 여기에 렌더링됩니다 -->
                </div>

                <!-- 필기 영역 -->
                <div class="space-y-2">
                    <h3 class="text-lg font-semibold text-gray-700">풀이 과정 필기</h3>
                    <div class="relative w-full border-2 border-dashed border-gray-300 rounded-lg">
                        <canvas 
                            id="drawing-canvas" 
                            class="w-full bg-gray-50 rounded-lg"
                            :style="{ height: canvasHeight + 'px' }"
                        ></canvas>
                        <div class="absolute top-2 right-2 flex flex-wrap gap-2 justify-end">
                            <button 
                                @click="toggleEraser" 
                                :class="isEraser ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-700'" 
                                class="px-3 py-1 rounded-md text-sm hover:bg-gray-300 transition"
                            >
                                {{ isEraser ? '펜' : '지우개' }}
                            </button>
                            <button @click="expandCanvas" class="px-3 py-1 bg-blue-100 text-blue-700 rounded-md text-sm hover:bg-blue-200 transition">
                                늘리기
                            </button>
                            <button @click="clearCanvas" class="px-3 py-1 bg-gray-200 text-gray-700 rounded-md text-sm hover:bg-gray-300 transition">&times; 지우기</button>
                            <button @click="getCanvasFeedback" :disabled="isLoading" class="px-3 py-1 bg-green-500 text-white rounded-md text-sm hover:bg-green-600 transition disabled:opacity-50">
                                <span v-if="!isLoading">내 풀이 피드백 받기</span>
                                <span v-else>분석 중...</span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- 정답 입력 영역 -->
                <div class="space-y-4">
                    <div class="flex flex-col sm:flex-row gap-2">
                        <input
                            type="text"
                            v-model="userAnswer"
                            :disabled="isAnswerDisabled"
                            @keyup.enter="submitAnswer"
                            placeholder="정답을 입력하세요 (예: -4)"
                            class="flex-grow px-4 py-3 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 transition disabled:bg-gray-100"
                        >
                        <button
                            @click="submitAnswer"
                            :disabled="isAnswerDisabled"
                            class="w-full sm:w-auto px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 transition disabled:opacity-50"
                        >
                            <span v-if="attemptCount === 0">제출하기</span>
                            <span v-else>다시 제출하기</span>
                        </button>
                    </div>
                    
                    <!-- 피드백 메시지 -->
                    <div v-if="feedback" :class="feedbackClass" class="text-center font-medium p-3 rounded-lg">
                        {{ feedback }}
                    </div>
                </div>

                <!-- 힌트 / 해설 / 다음 문제 버튼 영역 -->
                <div class="border-t pt-6 space-y-4">
                    <!-- 로딩 스피너 -->
                    <div v-if="isLoading" class="flex justify-center items-center space-x-2 text-gray-500">
                        <svg class="animate-spin h-5 w-5 text-blue-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                        <span>AI가 응답을 생성 중입니다...</span>
                    </div>

                    <!-- Gemini 응답 (힌트/해설) -->
                    <div 
                        v-if="geminiResponse" 
                        ref="geminiContainer"
                        class="p-4 bg-gray-50 border border-gray-200 rounded-lg leading-relaxed mathjax-container"
                    >
                        <!-- v-html 제거됨. AI 응답이 여기에 렌더링됩니다 -->
                    </div>

                    <!-- 상황별 버튼 -->
                    <div class="flex flex-wrap gap-2">
                        <!-- 1차 시도 실패 시 -->
                        <button
                            v-if="showHint1Button"
                            @click="callGemini('hint1')"
                            :disabled="isLoading"
                            class="flex-1 bg-yellow-500 text-white font-medium py-2 px-4 rounded-lg hover:bg-yellow-600 transition disabled:opacity-50"
                        >
                            힌트 보기 (1)
                        </button>

                        <!-- 2차 시도 실패 시 -->
                        <button
                            v-if="showHint2Button"
                            @click="callGemini('hint2')"
                            :disabled="isLoading"
                            class="flex-1 bg-yellow-600 text-white font-medium py-2 px-4 rounded-lg hover:bg-yellow-700 transition disabled:opacity-50"
                        >
                            다른 힌트 보기 (2)
                        </button>
                        <button
                            v-if="showSolutionButton"
                            @click="callGemini('solution')"
                            :disabled="isLoading"
                            class="flex-1 bg-green-600 text-white font-medium py-2 px-4 rounded-lg hover:bg-green-700 transition disabled:opacity-50"
                        >
                            해설 보기
                        </button>

                        <!-- 정답 맞췄거나 2번 틀렸을 때 -->
                        <button
                            v-if="isAnswerDisabled"
                            @click="startQuiz(selectedCategory)"
                            class="w-full mt-4 bg-gray-800 text-white font-bold py-3 px-6 rounded-lg hover:bg-gray-900 transition"
                        >
                            다음 문제 풀기 &rarr;
                        </button>
                    </div>
                </div>
            </section>

        </div>
    </div>

    <script type="module">
        const { createApp, ref, computed, onMounted, nextTick, watch } = Vue;

        createApp({
            
            setup() {
                // --- API 및 인증 ---
                const apiKey = ref(''); // Gemini API 키
                const apiKeyInput = ref(''); // API 키 입력 필드용
                const isApiKeySet = ref(false); // [FIX] 이 줄이 누락되었습니다.
                
                // --- 문제 데이터 ---
                const problems = ref([]); // 원본 문제 데이터
                const userRatings = ref({}); // 사용자 ELO 점수
                const selectedCategory = ref(''); // 현재 선택된 카테고리
                const currentProblem = ref(null); // 현재 출제된 문제

                // --- 문제 풀이 상태 ---
                const userAnswer = ref(''); // 사용자 답안
                const attemptCount = ref(0); // 시도 횟수
                const feedback = ref(''); // 정답/오답 피드백
                const geminiResponse = ref(''); // AI 응답 (힌트/해설)
                const isLoading = ref(false); // 로딩 상태 (API 호출)

                // --- 캔버스 상태 ---
                const canvas = ref(null);
                const ctx = ref(null);
                const isDrawing = ref(false);
                const canvasHeight = ref(300); // 캔버스 높이 (CSS 픽셀)
                const isEraser = ref(false); // 지우개 모드

                // [FIX] LaTeX 렌더링을 위한 DOM 요소 ref
                const problemContainer = ref(null);
                const geminiContainer = ref(null);

                // [FIX] currentProblem이 변경될 때마다 MathJax 렌더링 (v-html 대신 ref 사용)
                watch(currentProblem, (newProblem) => {
                    nextTick(() => {
                        if (newProblem && problemContainer.value) {
                            // 1. 수동으로 DOM 업데이트
                            problemContainer.value.innerHTML = newProblem.question;
                            // 2. 해당 요소만 MathJax로 렌더링
                            if (window.MathJax) {
                                MathJax.texReset(); // [FIX-1] 상태 리셋 추가
                                window.MathJax.typesetPromise([problemContainer.value])
                                    .catch((err) => console.error('MathJax (문제) 렌더링 오류:', err));
                            }
                        } else if (!newProblem && problemContainer.value) {
                            // 문제가 없을 때 (단원 선택 화면으로 돌아갈 때)
                            problemContainer.value.innerHTML = '';
                        }
                    });
                });

                // [FIX] Gemini 응답이 변경될 때마다 MathJax 렌더링
                watch(geminiResponse, (newResponse) => {
                    nextTick(() => {
                        // geminiContainer가 DOM에 마운트된 후 (v-if="geminiResponse") 실행됨
                        if (newResponse && geminiContainer.value) {
                            // 1. 수동으로 DOM 업데이트
                            geminiContainer.value.innerHTML = newResponse;
                            // 2. 해당 요소만 MathJax로 렌더링
                            if (window.MathJax) {
                                MathJax.texReset(); // [FIX-1] 상태 리셋 추가
                                window.MathJax.typesetPromise([geminiContainer.value])
                                    .catch((err) => console.error('MathJax (응답) 렌더링 오류:', err));
                            }
                        } else if (!newResponse && geminiContainer.value) {
                            // 응답이 비워졌을 때 (다음 문제 등)
                            geminiContainer.value.innerHTML = '';
                        }
                    });
                });

                // --- Computed: 계산된 속성 ---

                // 문제 JSON에서 고유한 카테고리 목록 추출
                const availableCategories = computed(() => {
                    const categories = problems.value.map(p => p.category);
                    return [...new Set(categories)];
                });

                // 정답/오답에 따른 피드백 메시지 스타일
                const feedbackClass = computed(() => {
                    if (feedback.value.includes('정답')) return 'bg-green-100 text-green-700';
                    if (feedback.value.includes('틀렸')) return 'bg-red-100 text-red-700';
                    return 'bg-gray-100 text-gray-700';
                });

                // 답안 입력창 비활성화 조건
                const isAnswerDisabled = computed(() => {
                    return attemptCount.value >= 2 || feedback.value.includes('정답');
                });
                
                // --- 상황별 버튼 표시 로직 ---
                const showHint1Button = computed(() => {
                    return attemptCount.value === 1 && !feedback.value.includes('정답');
                });
                const showHint2Button = computed(() => {
                    return attemptCount.value === 2 && !feedback.value.includes('정답');
                });
                const showSolutionButton = computed(() => {
                    return attemptCount.value === 2 && !feedback.value.includes('정답');
                });


                // --- Methods: 함수 ---

                // [FIX-2] Markdown 파서 옵션 설정
                if (window.marked) {
                    marked.setOptions({
                        breaks: true // \n을 <br>로 변환 (GitHub 스타일)
                    });
                }

                // MathJax 렌더링 큐에 등록 (이제 사용되지 않음, watch가 직접 처리)
                // const queueMathJaxTypeset = () => { ... };

                // API 호출 지수 백오프
                const fetchWithBackoff = async (url, options, retries = 5, delay = 1000) => {
                    try {
                        const response = await fetch(url, options);
                        if (!response.ok) {
                            // 429 (Too Many Requests) 또는 5xx (Server Error)일 때만 재시도
                            if ((response.status === 429 || response.status >= 500) && retries > 0) {
                                // console.log(`API ${response.status} 오류, ${delay}ms 후 재시도... (${retries}회 남음)`);
                                await new Promise(resolve => setTimeout(resolve, delay));
                                return fetchWithBackoff(url, options, retries - 1, delay * 2); // 딜레이 2배 증가
                            }
                            // 그 외 4xx 오류 등은 즉시 실패 처리
                            throw new Error(`API 오류: ${response.status} ${response.statusText}`);
                        }
                        return response.json();
                    } catch (error) {
                        // 네트워크 오류 등
                        if (retries > 0) {
                            // console.log(`네트워크 오류, ${delay}ms 후 재시도... (${retries}회 남음)`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                            return fetchWithBackoff(url, options, retries - 1, delay * 2);
                        }
                        // 최종 재시도 실패
                        throw error;
                    }
                };

                
                // --- 1. 인증 및 데이터 로드 ---
                
                // 쿠키 설정
                const setCookie = (name, value, days) => {
                    let expires = "";
                    if (days) {
                        const date = new Date();
                        date.setTime(date.getTime() + (days*24*60*60*1000));
                        expires = "; expires=" + date.toUTCString();
                    }
                    document.cookie = name + "=" + (value || "")  + expires + "; path=/; SameSite=Lax; Secure";
                };

                // 쿠키 가져오기
                const getCookie = (name) => {
                    const nameEQ = name + "=";
                    const ca = document.cookie.split(';');
                    for(let i=0; i < ca.length; i++) {
                        let c = ca[i];
                        while (c.charAt(0)==' ') c = c.substring(1,c.length);
                        if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);
                    }
                    return null;
                };

                // API 키 설정 (입력값 -> 상태 -> 쿠키)
                const setApiKey = () => {
                    if (apiKeyInput.value.trim()) {
                        apiKey.value = apiKeyInput.value.trim();
                        setCookie('geminiApiKey', apiKey.value, 30); // 30일간 저장
                        isApiKeySet.value = true;
                        apiKeyInput.value = '';
                    } else {
                        alert("API 키를 입력해주세요.");
                    }
                };

                // API 키 지우기 (쿠키 삭제)
                const clearApiKey = () => {
                    setCookie('geminiApiKey', '', -1); // 쿠키 만료
                    apiKey.value = '';
                    isApiKeySet.value = false;
                };

                // 문제 JSON 파일 비동기 로드
                const fetchProblems = async () => {
                    try {
                        const response = await fetch('https://raw.githubusercontent.com/corecreaters/laughing-octo-rotary-phone/refs/heads/main/problem2.json');
                        if (!response.ok) throw new Error('문제 데이터를 불러올 수 없습니다.');
                        const data = await response.json();
                        problems.value = data;
                        initializeUserRatings();
                    } catch (error) {
                        console.error(error);
                        feedback.value = "오류: 문제 데이터를 불러오지 못했습니다.";
                    }
                };
                
                // ELO 점수 초기화 (문제 로드 완료 시)
                const initializeUserRatings = () => {
                    const ratings = {};
                    availableCategories.value.forEach(cat => {
                        // 쿠키에서 저장된 점수 확인
                        const savedRating = getCookie(`elo_${cat}`);
                        ratings[cat] = savedRating ? parseInt(savedRating, 10) : 3;
                    });
                    userRatings.value = ratings;
                };

                // --- 2. 퀴즈 로직 ---

                // 퀴즈 시작 (카테고리 선택 시)
                const startQuiz = (category) => {
                    selectedCategory.value = category;
                    selectProblem();
                    nextTick(() => {
                        initCanvas();
                        // DOM이 렌더링된 후 MathJax 호출 (요청 1 수정) -> (요청 1 재수정) 여기서 호출 제거
                        // queueMathJaxTypeset(); 
                    });
                };
                
                // 퀴즈 상태 초기화 (다음 문제)
                const resetQuizState = () => {
                    userAnswer.value = '';
                    attemptCount.value = 0;
                    feedback.value = '';
                    geminiResponse.value = '';
                    clearCanvas();
                };

                // ELO 점수에 맞는 문제 선택
                const selectProblem = () => {
                    const elo = userRatings.value[selectedCategory.value];
                    const categoryProblems = problems.value.filter(p => p.category === selectedCategory.value);
                    
                    if (categoryProblems.length === 0) {
                        feedback.value = "이 카테고리에 더 이상 풀 문제가 없습니다.";
                        currentProblem.value = null;
                        return;
                    }

                    let matches = [];
                    const maxDifficulty = 5;
                    
                    // 1. ELO 점수와 정확히 일치하는 문제 탐색
                    matches = categoryProblems.filter(p => p.difficulty === elo);

                    // 2. (예외 처리) 일치하는 문제가 없다면, 근접한 난이도 탐색
                    if (matches.length === 0) {
                        for (let offset = 1; offset <= maxDifficulty; offset++) {
                            const lower = categoryProblems.filter(p => p.difficulty === elo - offset);
                            const upper = categoryProblems.filter(p => p.difficulty === elo + offset);
                            matches = [...lower, ...upper];
                            
                            // 근접 문제 발견 시 반복 중단
                            if (matches.length > 0) break;
                        }
                    }

                    // 3. (안전 장치) 그래도 문제가 없다면, 해당 카테고리의 모든 문제 중 무작위 선택
                    if (matches.length === 0) {
                        matches = categoryProblems;
                    }

                    // 4. 선택된 문제 리스트에서 무작위로 하나를 선택
                    currentProblem.value = matches[Math.floor(Math.random() * matches.length)];
                    resetQuizState(); // 문제 선택 후 상태 초기화
                    // queueMathJaxTypeset(); // (요청 1 수정) -> (요청 1 재수정) 여기서 호출 제거
                };

                // 답안 제출
                const submitAnswer = () => {
                    if (!userAnswer.value.trim()) {
                        feedback.value = "답을 입력해주세요.";
                        return;
                    }

                    const isCorrect = userAnswer.value.trim() === currentProblem.value.answer;
                    attemptCount.value++;
                    
                    if (isCorrect) {
                        feedback.value = `정답입니다! (${attemptCount.value}번째 시도)`;
                        const score = (attemptCount.value === 1) ? 1.0 : 0.5;
                        updateElo(score);
                    } else {
                        if (attemptCount.value === 1) {
                            feedback.value = "틀렸습니다. 다시 시도해보세요.";
                        } else {
                            feedback.value = `틀렸습니다. 정답은 ${currentProblem.value.answer} 입니다.`;
                            const score = 0.0;
                            updateElo(score);
                        }
                    }
                };

                // ELO 점수 업데이트
                const updateElo = (score) => {
                    const category = selectedCategory.value;
                    let currentRating = userRatings.value[category];
                    
                    // 요구사항: 0~5 정수, ELO 방식 B (1.0=승, 0.5=무, 0.0=패)
                    // 가장 단순한 ELO 매핑: 승리 시 +1, 패배 시 -1, 무승부 시 0
                    let newRating = currentRating;
                    if (score === 1.0) {
                        newRating = Math.min(5, currentRating + 1); // 5점 초과 방지
                    } else if (score === 0.0) {
                        newRating = Math.max(0, currentRating - 1); // 0점 미만 방지
                    }
                    // score === 0.5 (무승부)일 때는 점수 변동 없음

                    userRatings.value[category] = newRating;
                    
                    // ELO 점수를 쿠키에 저장
                    setCookie(`elo_${category}`, newRating, 365);
                };
                
                // --- 3. Gemini API 호출 ---
                
                // Gemini API 호출 메인 함수
                const callGemini = async (promptType) => {
                    isLoading.value = true;
                    geminiResponse.value = '';
                    
                    let systemPrompt = "당신은 학생들을 돕는 친절하고 명확한 고등학교 수학 선생님입니다.";
                    let userQuery = "";
                    let payload = {};

                    const { question, answer } = currentProblem.value;

                    // 요청 유형에 따른 프롬프트 구성
                    switch (promptType) {
                        case 'hint1':
                            userQuery = `다음 수학 문제를 풀어야 합니다.
[문제]: ${question}
학생이 문제를 풀 수 있도록, 정답이나 전체 풀이 과정을 직접적으로 알려주지 않는 '첫 번째 힌트'를 한두 문장으로 제공해주세요. 어떤 공식이나 개념을 사용해야 하는지 알려주는 것이 좋습니다.`;
                            break;
                        case 'hint2':
                            userQuery = `다음 수학 문제를 풀어야 합니다.
[문제]: ${question}
학생이 이미 첫 번째 힌트를 봤지만 여전히 어려워합니다. 정답을 알려주지 않으면서, 문제 해결에 결정적인 '추가 힌트'를 한두 문장으로 제공해주세요.`;
                            break;
                        case 'solution':
                            userQuery = `다음 수학 문제의 정답과 상세한 풀이 과정을 단계별로 설명해주세요.
[문제]: ${question}
[정답]: ${answer}
수식은 LaTeX 형식을 사용해주세요. (예: $f(x)$)`;
                            break;
                        case 'feedback':
                            systemPrompt = "당신은 학생의 수학 풀이 과정을 첨삭하는 전문 선생님입니다. 수식은 LaTeX 형식을 사용해주세요.";
                            const imageData = canvas.value.toDataURL('image/png').split(',')[1]; // Base64 데이터 추출
                            userQuery = `아래 [문제]에 대한 [학생의 필기 풀이 과정] 이미지입니다.
[문제]: ${question}
[학생의 풀이 과정]:
학생의 풀이 과정을 검토하고, 다음 항목에 대해 피드백해주세요.
1. **접근 방식:** 올바른 방향으로 접근했나요?
2. **오류 지점:** (틀렸다면) 계산 실수나 개념 오류가 발생한 지점을 정확히 짚어주세요.
3. **격려 및 조언:** 학생에게 격려와 함께 어떤 점을 보완하면 좋을지 조언해주세요.`;
                            
                            payload = {
                                contents: [{
                                    parts: [
                                        { "text": userQuery },
                                        { "inlineData": { "mimeType": "image/png", "data": imageData } }
                                    ]
                                }],
                                systemInstruction: { parts: [{ text: systemPrompt }] },
                            };
                            break;
                    }
                    
                    // 'feedback'이 아닌 경우의 payload
                    if (promptType !== 'feedback') {
                        payload = {
                            contents: [{ parts: [{ text: userQuery }] }],
                            systemInstruction: { parts: [{ text: systemPrompt }] },
                        };
                    }
                    
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey.value}`;

                    try {
                        const result = await fetchWithBackoff(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        
                        const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
                        if (text) {
                            // [FIX-2] API 응답을 Markdown으로 파싱
                            geminiResponse.value = marked.parse(text); 
                            // [FIX] queueMathJaxTypeset(); // 호출 제거 (watch가 처리)
                        } else {
                            throw new Error("API로부터 유효한 응답을 받지 못했습니다.");
                        }
                    } catch (error) {
                        console.error('Gemini API 호출 오류:', error);
                        geminiResponse.value = `오류가 발생했습니다: ${error.message}. API 키를 확인하거나 나중에 다시 시도해주세요.`;
                    } finally {
                        isLoading.value = false;
                    }
                };

                // --- 4. 캔버스 로직 ---
                
                // --- 4. 캔버스 로직 (요청 2, 3 반영) ---
                
                // 펜/지우개 모드 설정 헬퍼 (요청 3)
                const setDrawingMode = () => {
                    if (!ctx.value) return;
                    
                    if (isEraser.value) {
                        // 지우개 모드
                        ctx.value.globalCompositeOperation = 'destination-out';
                        ctx.value.strokeStyle = 'rgba(0,0,0,1)'; // destination-out을 위해 불투명해야 함
                        ctx.value.lineWidth = 20; // 지우개 크기
                    } else {
                        // 펜 모드
                        ctx.value.globalCompositeOperation = 'source-over';
                        ctx.value.strokeStyle = '#374151'; // text-gray-700
                        ctx.value.lineWidth = 2; // 펜 크기
                    }
                    ctx.value.lineCap = 'round';
                };

                // 지우개 모드 토글 (요청 3)
                const toggleEraser = () => {
                    isEraser.value = !isEraser.value;
                    setDrawingMode();
                };
                
                // 캔버스 늘리기 (요청 2)
                const expandCanvas = () => {
                    canvasHeight.value += 150; // 높이 150px 증가
                };
                
                // 캔버스 높이 변경 감지하여 리사이즈 (요청 2)
                watch(canvasHeight, (newHeight) => {
                    if (canvas.value && ctx.value) {
                        const dpr = window.devicePixelRatio || 1;
                        
                        // 1. 현재 그림 저장
                        const dataUrl = canvas.value.toDataURL();
                        
                        // 2. 캔버스 물리적 크기 조절
                        // (너비도 창 크기에 맞춰 다시 계산)
                        const rect = canvas.value.getBoundingClientRect();
                        canvas.value.width = rect.width * dpr;
                        canvas.value.height = newHeight * dpr;
                        
                        // 3. 컨텍스트 스케일 재설정 (리사이즈 시 초기화됨)
                        ctx.value.scale(dpr, dpr);
                        
                        // 4. 배경색 다시 채우기
                        clearCanvas();
                        
                        // 5. 펜/지우개 모드 재설정
                        setDrawingMode(); 
                        
                        // 6. 저장한 그림 다시 그리기
                        const img = new Image();
                        img.onload = () => {
                            // (컨텍스트가 dpr로 스케일되었으므로, 0,0에 그리면 CSS 픽셀에 맞게 그려짐)
                            ctx.value.drawImage(img, 0, 0); 
                        };
                        img.src = dataUrl;
                    }
                });

                // 캔버스 초기화
                const initCanvas = () => {
                    const canvasEl = document.getElementById('drawing-canvas');
                    if (!canvasEl) return;
                    
                    canvas.value = canvasEl;
                    ctx.value = canvasEl.getContext('2d');
                    
                    // 캔버스 해상도 조절 (레티나 디스플레이 대응)
                    const dpr = window.devicePixelRatio || 1;
                    const rect = canvasEl.getBoundingClientRect();
                    canvasEl.width = rect.width * dpr;
                    canvasEl.height = canvasHeight.value * dpr; // (요청 2) ref 값 사용
                    
                    ctx.value.scale(dpr, dpr); // (중요) 컨텍스트를 CSS 픽셀 기준으로 스케일
                    
                    clearCanvas(); // 캔버스 초기화
                    setDrawingMode(); // (요청 3) 펜/지우개 모드 설정
                    
                    // 이벤트 리스너 등록
                    canvasEl.addEventListener('mousedown', startDrawing);
                    canvasEl.addEventListener('mousemove', draw);
                    canvasEl.addEventListener('mouseup', stopDrawing);
                    canvasEl.addEventListener('mouseout', stopDrawing);
                    
                    canvasEl.addEventListener('touchstart', startDrawing);
                    canvasEl.addEventListener('touchmove', draw);
                    canvasEl.addEventListener('touchend', stopDrawing);
                };

                // 캔버스 이벤트 좌표 보정 (버그 수정)
                const getEventPosition = (e) => {
                    const rect = canvas.value.getBoundingClientRect();
                    let clientX, clientY;
                    if (e.touches) {
                        clientX = e.touches[0].clientX;
                        clientY = e.touches[0].clientY;
                    } else {
                        clientX = e.clientX;
                        clientY = e.clientY;
                    }
                    // 컨텍스트가 dpr로 스케일되었으므로, CSS 픽셀 좌표 반환
                    return {
                        x: clientX - rect.left,
                        y: clientY - rect.top
                    };
                };

                // 그리기 시작
                const startDrawing = (e) => {
                    e.preventDefault();
                    isDrawing.value = true;
                    const { x, y } = getEventPosition(e);
                    ctx.value.beginPath();
                    ctx.value.moveTo(x, y);
                };
                
                // 그리기
                const draw = (e) => {
                    if (!isDrawing.value) return;
                    e.preventDefault();
                    const { x, y } = getEventPosition(e);
                    ctx.value.lineTo(x, y);
                    ctx.value.stroke();
                };

                // 그리기 중지
                const stopDrawing = () => {
                    if (isDrawing.value) {
                        ctx.value.closePath();
                        isDrawing.value = false;
                    }
                };
                
                // 캔버스 지우기
                const clearCanvas = () => {
                    if (ctx.value && canvas.value) {
                        // 흰색 배경으로 채우기 (투명 PNG 방지)
                        ctx.value.fillStyle = '#f9fafb'; // bg-gray-50
                        ctx.value.fillRect(0, 0, canvas.value.width, canvas.value.height);
                    }
                };

                // 캔버스 피드백 요청
                const getCanvasFeedback = () => {
                    if (isLoading.value) return;
                    callGemini('feedback');
                };

                // --- 5. 마운트 ---
                
                onMounted(() => {
                    // 1. 쿠키에서 API 키 확인
                    const savedKey = getCookie('geminiApiKey');
                    if (savedKey) {
                        apiKey.value = savedKey;
                        isApiKeySet.value = true;
                    }
                    
                    // 2. 문제 데이터 로드
                    fetchProblems();
                });

                // Vue 인턴스가 반환할 데이터와 함수들
                return {
                    apiKey,
                    apiKeyInput,
                    isApiKeySet,
                    problems,
                    userRatings,
                    selectedCategory,
                    currentProblem,
                    userAnswer,
                    attemptCount,
                    feedback,
                    geminiResponse,
                    isLoading,
                    availableCategories,
                    feedbackClass,
                    isAnswerDisabled,
                    showHint1Button,
                    showHint2Button,
                    showSolutionButton,
                    // (요청 2, 3) 추가된 상태 및 함수
                    canvasHeight,
                    isEraser,
                    toggleEraser,
                    expandCanvas,
                    // [FIX] 렌더링을 위한 ref 추가
                    problemContainer,
                    geminiContainer,
                    //
                    setApiKey,
                    clearApiKey,
                    startQuiz,
                    submitAnswer,
                    callGemini,
                    initCanvas,
                    clearCanvas,
                    getCanvasFeedback
                };
            }
        }).mount('#app');
    </script>
</body>
</html>